# frontend_recipe
frontend_recipe shows you how to develop a CRUD app using Sencha's tools. The project showase a recipe management tool where recipes have ingredients attached to them by recipe id. As of today, there is no security implemented. 

The roor folder is primarily a container for the top-level pieces of the application.
While you can remove some files and folders that this application does not use,
be sure to read below before deciding what can be deleted and what needs to be
kept in source control.

The following files are all needed to build and load the application.

 - `"app.json"` - The application descriptor which controls how the application is
   built and loaded.
 - `"app.js"` - The file that launches the application. This is primarily used to
   launch an instance of the `MyApp.Application` class.
 - `"index.html"` - The default web page for this application. This can be customized
   in `"app.json"`.
 - `"build.xml"` - The entry point for Sencha Cmd to access the generated build
   script. This file is a place where you can hook into these processes and tune
   them. See the comments in that file for more information.

These files can be ignored from source control as they are regenerated by the build
process.

 - `"build"` - This folder contain the output of the build. The generated CSS file,
   consolidated resources and concatenated JavaScript file are all stored in this
   folder.
 - `"bootstrap.*"` - These files are generated by the build and watch commands to
   enable the application to load in "development mode".

## Basic Application Structure

Applications that target a single toolkit will have the following structure.

    app/                # Contains JavaScript and Theme code
        model/          # Data model classes, 
        view/           # Views as well as ViewModels and ViewControllers
        store/          # Data stores
        controller/     # Global / application-level controllers

    overrides/          # JavaScript code that is automatically required

    resources/          # Assets such as images, fonts, etc.

### app/

This folder contains JavaScript (.js files) and styling (.scss files) common
for all builds of the application.

#### app/controller/

This folder contains the application's global controllers. ViewControllers are located
alongside their respective view class in `"./view"`. These controllers are used for routing
and other activities that span all views.

#### app/model/

This folder contains the application's (data) Model classes.

To illustrate the basic structure of a model, we are going to take a look at the Recipe Model. The Recipe model represents a recipe entity in our application. It defines various fields that correspond to the attributes of a recipe, such as title, description, preparation time, author, type, and so on. Additionally, it specifies associations with other models and sets up a proxy for data communication with the server.
* Fields - 
The fields property defines the data fields present in the Recipe model. Each field is an object with properties like name and type. Here is a list of the fields and their descriptions:
  1. title (type: string): The title of the recipe.
  2. description (type: string): A brief description of the recipe.
  3. preparationtime (type: int, sortType: asInt): The time required to prepare the recipe in minutes. The sortType: 'asInt' ensures numeric sorting.
  4. author (type: string): The name of the recipe author.
  5. type (type: string): The type or category of the recipe.
  6. recipeId (type: string, persist: false, unique: true, identifier: sequential): The unique identifier of the recipe. The persist: false indicates that this field should not be saved to the server. The unique: true ensures that each recipe has a unique identifier. The identifier: sequential specifies that the identifier should be generated sequentially.
  7. recipesteps (type: int): The number of steps in the recipe.
  8. instructions (type: string): Detailed instructions on how to prepare the recipe.
  9. imagepath (type: string): The path to the image associated with the recipe.
  10. Calories (type: number): The calorie count of the recipe.
* Associations - 
The Recipe model has a one-to-many association with the CountryTags model. This means that a recipe can be associated with multiple country tags. The association is defined using the hasMany property.
* Proxy - 
The proxy property specifies how the Recipe model communicates with the server to perform CRUD operations (Create, Read, Update, Delete). It is set up as an AJAX proxy to interact with the server through JSON data.
type: 'ajax': Specifies that an AJAX proxy is used for data communication.
  1. url: 'https://localhost:7270/api/recipe': The URL where the server API for recipes is located. (For an implementation of      the server API logic, please refer to https://github.com/malkhabir/WebAPI_recipe.git)
  2. reader: Specifies the reader for reading data from the server response. In this case, we use a JSON reader.
  3. writer: Specifies the writer for writing data to the server. We set writeAllFields: true to include all fields of the model in the request.
Overall, the Recipe model provides a structured representation of a recipe and handles data communication with the server using an AJAX proxy. This model can be used with stores and views to manage recipe data in our application.

#### app/view/

This folder contains the views as well as ViewModels and ViewControllers depending on the
application's architecture. Pure MVC applications may not have ViewModels, for example. For
MVCVM applications or MVC applications that use ViewControllers, the following directory
structure is recommended:

    app/view/
        foo/                    # Some meaningful grouping of one or more views
            Foo.js              # The view class
            Foo.scss            # The view class styling
            FooController.js    # The controller for Foo (a ViewController)
            FooModel.js         # The ViewModel for Foo

This structure helps keep these closely related classes together and easily identifiable in
most tabbed IDE's or text editors.

To understand how a view is used, we are going to take a look at the RecipeGrid View. The RecipeGrid View is a panel with Columns, Docked Items  This grid is designed to display and manage recipe data, allowing users to view, add, edit, and delete recipes.. This grid contains:

   1. Columns
      The Columns config contains headers with header written like this:
      
    a. text: The header title. 
    b. dataIndex: 'title' given the following json data object {title: "Scrambled Eggs",...}

   3. Docked Items
   The grid has a top docked toolbar containing the following items:

     a. Add: A button to add a new recipe. Clicking this button triggers the 'onAddClick' handler.    
     b. Edit: A button to edit the selected recipe. This button is initially disabled and becomes enabled               when a recipe is selected in the grid. Clicking this button triggers the 'onEditClick' handler.
     c. Delete: A button to delete the selected recipe. This button is initially disabled and becomes enabled           when a recipe is selected in the grid. Clicking this button triggers the 'onDeleteClick' handler.
   
   5. Listeners (Not visible)
   The grid listens for the 'selectionchange' event and triggers the 'onSelectionChange' handler when the selection of items in the grid changes.

Note: The handlers for 'onAddClick', 'onEditClick', and 'onDeleteClick', as well as the 'onSelectionChange' handler, are defined in the 'recipegridcontroller' controller.

#### app/store/

This folder contains any number of store instances or types that can then be reused in the
application.

## Overrides

The contents of "overrides" folders are automatically required and included in
builds. These should not be explicitly mentioned in "requires" or "uses" in code.
This area is intended for overrides like these:

    Ext.define('frontend_recipe.overrides.foo.Bar', {
        override: 'Ext.foo.Bar',
        ...
    });

Such overrides, while automatically required, will only be included if their target
class ("Ext.foo.Bar" in this case) is also required. This simplifies applying
patches or extensions to other classes.

#### Endpoints
 The Endpoints used in the frontend are defined in [repo](https://github.com/malkhabir/WebAPI_recipe.git). 

